function p = NLG_PRE_sync_Nlx2Nlg_by_TTL_2_0(p)
dbstop if error

%% Parameters
run_in_chunks_to_save_memory=0; % 1 - runs cross-corr in chunks to avoid memory overload or 0 - run in one piece (for stronger computers)
Nlg_event_delay_ms = 0; % Changed to '0' becasue TTL is now generated by transiever and there is no PC delay (used to be 35msec - This is the average delay introduced by the PC (between the emission of TTL pulse and the registration of the TTL-out event). 
                        % Positive value - means that the TTL pulse was emitted before the TTL-out event was saved in the log-file.
heaviside_template_window = 50; %in number of samples. Thi is the half window size of the step function (before the step, and the same length after the step).
cross_corr_detection_peak_shift = 50; %in units of samples (for heaviside template of length 100(50 -1 and 50 +1);
% cross_corr_threshold=6*10^5; %changed by Gily due to detection on non-TTLs %5*10^5; %used to identify the peaks of the crosscorrelation, corresponding to the rising phase of the TTL
cross_corr_threshold = 1*10^5; % changed by Maya due to non-detection on of TTLs %5*10^5; 
                             % used to identify the peaks of the crosscorrelation, corresponding to the rising phase of the TTL
max_jitter_between_TTL_pairs = 80;  %in ms  - this is the maximal acceptablle jitter between the Nlx and Nlg TTLs pairs, that will be used for synchronization
max_residual_TTL_fit_ms=15; % if the residual time between the data and the fit is bigger than this, we will recalculate the fit without this TTL time
filename_data_to_save = fullfile(p.path_dataout, p.datadir_out, 'TTLs_and_Nlx2Nlg_clock_fits.mat');
filename_error = fullfile(p.path_dataout, p.datadir_out, 'error_sync.mat');
TTL_tresh = 5;

%intializing.
error_sync=0;  %If there will be an error in sync (i.e. no good TTLs pairs) it will change to 1
TTL_timestamps_Nlx=[];
polyfit_Nlg2Nlx_microsec=[];
polyfit_Nlx2Nlg_microsec=[];

%% ======== Extract CSC min-max data  ============
Nlg_event_delay_ms=0;               % This is the average delay introduced by the PC (between the emission of TTL pulse and the registration of the TTL-out event). Positve value - means that the TTL pulse was emitted before the TTL-out event was saved in the log-file
max_jitter_between_TTL_pairs = 80;  %in ms  - this is the maximal acceptablle jitter between the Nlx and Nlg TTLs pairs, that will be used for synchronization
max_residual_TTL_fit_ms = 15;       % if the residual time between the data and the fit is bigger than this, we will recalculate the fit without this TTL time
folder_name = fullfile(p.path_dataout, p.datadir_out);

TTL_tresh = 5; 

%intializing.
error_sync = 0;  %If there will be an error in sync (i.e. no good TTLs pairs) it will change to 1

%% 1) Extracting the TTLs from the Neurolynx CSC and from the p structure for the neurlogger
% we want to extract all 
file_name_Nlx_TTL = fullfile(p.path_datain, p.data_dir, 'Events.nev');
FieldSelection = [1 1 1 1 1];
ExtractHeader = 1; %We want to extract the header
ExtractMode = 1; % we want to extract the whole range

[Timestamps, EventIDs, TTLs, Extras, EventStrings, Header] =...
    Nlx2MatEV( file_name_Nlx_TTL, FieldSelection, ExtractHeader,...
    ExtractMode, [] );
TTL_timestamps_Nlx = Timestamps(logical(TTLs));  % in microsec 
TTL_timestamps_Nlx = TTL_timestamps_Nlx(:)';

p.nlg.TTL_timestamps_nlx = TTL_timestamps_Nlx;

file_name_Nlg_TTL = fullfile(p.path_dataout, p.datadir_out, 'nlx_data', 'EVENTS__Digital out.nev');
[nlgTimestamps, nlgEventIDs, nlgTTLs, nlgExtras, nlgEventStrings, nlgHeader] =...
    Nlx2MatEV( file_name_Nlg_TTL, FieldSelection, ExtractHeader,...
    ExtractMode, [] );

p.nlg.TTL_timestamps_Nlg = nlgTimestamps;

% Extract Nlg TTL timestamps
TTL_timestamps_Nlg = (p.nlg.TTL_timestamps_Nlg'/1000) - Nlg_event_delay_ms; %in millisec

% new solution using align_timestamps script
offset = 10*1e6; % mimimum offest between each pulse in microseconds
[p.nlg.align_timestamps_nlx2nlg, amatch, bmatch] = align_timestamps(TTL_timestamps_Nlx, nlgTimestamps, offset);
[p.nlg.align_timestamps_nlg2nlx, amatch, bmatch] = align_timestamps(nlgTimestamps, TTL_timestamps_Nlx, offset);
% 
% %% 2) Detecting missalignments (misses or false positive) between Nlx and Nlg TTLs
% %Creating a vector from the first to the last TTL,  with bin size of 1 ms,
% TTL_Nlx = zeros(1,ceil((TTL_timestamps_Nlx(end) - TTL_timestamps_Nlx(1))/1000)); 
% TTL_Nlg = zeros(1,ceil(TTL_timestamps_Nlg(end)-TTL_timestamps_Nlg(1))); 
% 
% % Placing 1 at a timestamp (with bin of 1 ms) where a TTL was sent (Nlg) or detected (Nlx)
% TTL_Nlx (round( (TTL_timestamps_Nlx - TTL_timestamps_Nlx(1))/1000) +1 )=1;
% TTL_Nlg (round( (TTL_timestamps_Nlg - TTL_timestamps_Nlg(1))) +1 )=1;
%  
% % normelizing the kernel ; didi 25.8.2015
% % very important the the kernal duration will be up to 1/10 of the average jitter
% % used in the Neurolloger to produe the TTLs  
% kernel = hamming(100)/sum(hamming(100));  
% 
% % paddign the vectors with zeros to avoid edge effect on the fitlering ; didi 25.8.2015
% TTL_Nlx = [ zeros(1,length(kernel)*2),TTL_Nlx, zeros(1,length(kernel)*2)]; 
% TTL_Nlg = [ zeros(1,length(kernel)*2),TTL_Nlg, zeros(1,length(kernel)*2)]; 
% 
% % smoothing with Hamming window(almost gaussian...;)) ; didi 25.8.2015
% TTL_Nlg_smoothed = filtfilt(kernel,1,TTL_Nlg); 
% TTL_Nlx_smoothed = filtfilt(kernel,1,TTL_Nlx);
% TTL_Nlx_smoothed = TTL_Nlx_smoothed(length(kernel)*2 +1:end - (length(kernel)*2));  
% TTL_Nlg_smoothed = TTL_Nlg_smoothed(length(kernel)*2 +1:end - (length(kernel)*2)); 
% [c_Nlg_Nlx, lag] = xcorr(TTL_Nlg_smoothed,TTL_Nlx_smoothed);
% 
% % finding the delay in ms
% [~,shift_Nlg_Nlx_ms ] = max(c_Nlg_Nlx);
% shift_Nlg_Nlx_ms   = lag(shift_Nlg_Nlx_ms)+ TTL_timestamps_Nlg(1); % absolute shift!  (Didi) 
% TTL_timestamps_Nlx_shift = (TTL_timestamps_Nlx- TTL_timestamps_Nlx(1)) + shift_Nlg_Nlx_ms*1000;
% 
% % remove zero padding from the vectors 
% TTL_Nlx= TTL_Nlx(length(kernel)*2 +1:end - (length(kernel)*2));  
% TTL_Nlg = TTL_Nlg(length(kernel)*2 +1:end - (length(kernel)*2)); 
% axis_TTL_Nlg = linspace(0,length(TTL_Nlg)-1,length(TTL_Nlg)); 
% axis_TTL_Nlx = linspace(0,length(TTL_Nlx)-1,length(TTL_Nlx));
% axis_TTL_Nlx = axis_TTL_Nlx+ (shift_Nlg_Nlx_ms-TTL_timestamps_Nlg(1))+1;
% intersect_idx = find(axis_TTL_Nlg>=axis_TTL_Nlx(1)-100 & axis_TTL_Nlg<=axis_TTL_Nlx(end)+100);
% 
% %% 3) Aligning the TTLs (in case there were misses) and taking only the TTLs that were present both in Nlg and Nlx
% % Updating the Nlx timestamps by the shift (in micro s), which could result
% % from missalignment of the TTL trains i.e. - false positive/negative)
% 
% % detecting legitimate TTL pairs from Nlg and Nlx 
% TTL_timestamps_Nlg = TTL_timestamps_Nlg(:)';
% TTL_timestamps_Nlx_shift = TTL_timestamps_Nlx_shift(:)';
% 
% d  = abs(repmat(TTL_timestamps_Nlx_shift(:),1,length(TTL_timestamps_Nlg)) - repmat(TTL_timestamps_Nlg*1000,length(TTL_timestamps_Nlx_shift),1));  
% [d,ii] = min(d');
% ii2 = find(d/1000 <= max_jitter_between_TTL_pairs);
% d = d(ii2);
% ii = ii(ii2); 
% TTL_timestamps_Nlg_valid = TTL_timestamps_Nlg(ii);
% 
% TTL_timestamps_Nlx = TTL_timestamps_Nlx(ii2);
% 
% %% 4) Computing the initial fit (for conversion of Nlx timestamps into Nlg timestamps) and residuals on matching TTLs
% [initial_polyfit_Nlg2Nlx_microsec,~,muNlg2Nlx1] = polyfit(TTL_timestamps_Nlg_valid*1000, TTL_timestamps_Nlx , 1);
% [initial_polyfit_Nlx2Nlg_microsec,~,muNlx2Nlg1] = polyfit(TTL_timestamps_Nlx , TTL_timestamps_Nlg_valid*1000,  1);
% 
% % Computing the residuals on matching TTLs ( i.e. how much each actual measured TTL was different from the fit)
% matching_TTL_residuals_times =TTL_timestamps_Nlg_valid-  polyval(initial_polyfit_Nlx2Nlg_microsec,TTL_timestamps_Nlx,[],muNlx2Nlg1)/1000; %if positive - it means that Nlx is ahead of neurologger
% 
% % Identifying 'Good' and 'Bad' TTL pairs based on the residuals of the inital fit
% %good
% idx_good_TTL_Nlg= find(abs(matching_TTL_residuals_times)<max_residual_TTL_fit_ms);
% idx_good_TTL_Nlx= find(abs(matching_TTL_residuals_times)<max_residual_TTL_fit_ms);
% %bad
% idx_bad_TTL_Nlg= find(abs(matching_TTL_residuals_times)>max_residual_TTL_fit_ms);
% idx_bad_TTL_Nlx= find(abs(matching_TTL_residuals_times)>max_residual_TTL_fit_ms);
% 
% idx_valid_TTL_Nlg = ii(idx_good_TTL_Nlg); 
% idx_valid_TTL_Nlx = idx_good_TTL_Nlx;
% 
% %% 5) Recalculating the final fit (for conversion of Nlx timestamps into Nlg timestamps) and residuals on Good TTL, i.e. - those TTL whose residuals didn't deviate significantly from the intial fit
% [p.nlg.polyfit_Nlg2Nlx_microsec, ~, p.nlg.muNlg2Nlx] = polyfit(TTL_timestamps_Nlg_valid(idx_good_TTL_Nlg)*1000, TTL_timestamps_Nlx(idx_good_TTL_Nlx), 1);
% [p.nlg.polyfit_Nlx2Nlg_microsec, ~, p.nlg.muNlx2Nlg] = polyfit(TTL_timestamps_Nlx(idx_good_TTL_Nlx),TTL_timestamps_Nlg_valid(idx_good_TTL_Nlg)*1000,  1);
% p.nlg.clock_lag_Nlg2Nlx_micro_sec = polyval(p.nlg.polyfit_Nlg2Nlx_microsec,0,[],p.nlg.muNlg2Nlx); %if positive - it means that Nlx is ahead of neurologger
% 
% % Computing the residuals on final TTL - i.e. based on Good TTL
% good_TTL_residuals_times = TTL_timestamps_Nlg_valid(idx_good_TTL_Nlg)-  polyval(p.nlg.polyfit_Nlx2Nlg_microsec,TTL_timestamps_Nlx(idx_good_TTL_Nlx),[],p.nlg.muNlx2Nlg)/1000; %if positive - it means that Nlx is ahead of neurologger
% 
% if isempty(idx_good_TTL_Nlg)
%     disp('===========');
%     disp(['ERROR in SYNC of Nlx TTLs for ',file_name_Nlx_TTL])
%     disp('===========');
%     error_sync=1;
%     return;
% end
% 
% %% 7) Saving the fit
% 
% % Saving the fit and the TTLs
% TTLs_and_Nlx2Nlg_clock_fits.TTL_timestamps_Nlg = TTL_timestamps_Nlg;
% TTLs_and_Nlx2Nlg_clock_fits.TTL_timestamps_Nlx = TTL_timestamps_Nlx;
% TTLs_and_Nlx2Nlg_clock_fits.idx_good_TTL_Nlg = idx_valid_TTL_Nlg;
% TTLs_and_Nlx2Nlg_clock_fits.idx_good_TTL_Nlx = idx_valid_TTL_Nlx;
% TTLs_and_Nlx2Nlg_clock_fits.polyfit_Nlg2Nlx_microsec = polyfit_Nlg2Nlx_microsec;
% TTLs_and_Nlx2Nlg_clock_fits.polyfit_Nlx2Nlg_microsec = polyfit_Nlx2Nlg_microsec;
% TTLs_and_Nlx2Nlg_clock_fits.muNlx2Nlg = muNlx2Nlg1; 
% TTLs_and_Nlx2Nlg_clock_fits.muNlg2Nlx = muNlg2Nlx1; 
%  
% save(filename_data_to_save,'-struct','TTLs_and_Nlx2Nlg_clock_fits');
% % set(0,'DefaultFigureWindowStyle','docked');
end


